Вместе с проектами заливал и их билды, чтобы можно было показать результат без лишних деплоев на сторонних серверах.

В качестве пакетного менеджера использовал npm. Если будете качать проекты на локал, то он понадобиться. После скачки из папки любого проекта просто

npm run start

все настроено.

Для запуска без установок пакетов

npm run restart


Теперь по каждому из заданий

******************************
task_1
----------
Просмотр результата: https://vladimirleontev281.github.io/testTask_res/task_1/dist

Коментарии.

  Мне кажется, что правильнее, когда класс-модификатор присваиваться основному блоку,
  а через него (класс-модификатор блока) активируются css-свойства внутренних элементов.

  Но ТЗ требует присваивать "red" на сам input.
  Для того, чтобы не отойти от ТЗ дополнительно к своему видению реализации 
  добавил буквальное исполнение (строки помеченные (*)).
  Но если буквальность не так важна, то строки (*) стоит удалить 
  (как и блок .box__input.red в index.css).

  Немного разнообразил задачу. Надеюсь не будет воспринято как злостное нарушение ТЗ. :)
  А вообще, все что касается additional необязательно и это можно исключить из html, css и js
  без потери основной работоспособности (только если исключать, то везде :) )

Сборка просто для отработки старта статического сервера, если будете качать на локал. Для CSS добавил стандартный набор (автопрефиксер, склейка, минификация) просто чтоб было :). Остальное просто копируется в билд-директорию.

******************************
task_2
----------
Просмотр результата: https://vladimirleontev281.github.io/testTask_res/task_2/dist/filter?size=M&color=1&color=2&manufacturer=aaa&manufacturer=ddd

Параметры можно менять местами, исключать (вплоть до url без параметров), вводить непредусмотренные параметры и непредусмотренные значения. Логика следующая:

- непредусмотренные параметры игнорируются;
- непредусмотренные значения предусмотренных параметров игнорируется;
- если для радиобатона или чекбокса "распродажа" в url содержится несколько вариантов значения, то логика отработает по тому, которое встречается первым, остальные игнорируются;
- в случае отсутсятвия в url-параметрах валидных значений параметров или параметров в принципе, то логика следующая:
    - радиобатн либо пуст, либо дефолтное значение,
    - чекбоксы неактивны,
    - нет активных значений,
    - чекбокс "распродажа" неактивен.

"Либо" обусловлено флагом DEFAULT=true/false (константа в начале кода). В случае DEFAULT=true при отсутствии/невалидности значений в url-параметрах радиобатону присвоится дефолтное значение. Дефолтные значения находятся в описании класса.

Попробовал офрмить проект по БЭМ, уж не знаю получилось ли :). Соответственно был необходим сборщик для склейки. Для HTML склейка модулей. Для CSS стандартный набор - склейка, автопрефиксер, минификация. Для js над кроссбраузеностью не заморачивался, подумал что для такого маленького проекта тянуть babel и webpack будет слишком. Просто копируется.

******************************
task_3
----------
Просмотр результата: https://vladimirleontev281.github.io/testTask_res/task_3/dist/

Сделал эмуляцию задержки ответа сервера. Время задержки в константах в начале кода, там интуитивно понятно.

Немного разнообразил задачу. Добавил preloader, который работает от нажатия кнопки до получения ответов от псевдосервера, и прописал простенький оповещатель дополнительно к выводу в консоль.

Сборка: HTML просто копируется, JS - склейка (хоть там и один файл), на CSS стандартный набор - склейка, автопрефиксер, минификация. 

Анимация preloader-а позаимствована отсюда: https://nisnom.com/veb-razrabotki/tappy-loader-prikolnaya-css-animatsiya-v-vide-stuchashhih-paltsev-po-stolu/#more-3062

******************************
task_4
----------

Просмотр результата: 

domain_1: https://vladimirleontev281.github.io/testTask_res/task_4/domain_1/dist/

domain_2: https://vladimirleontev281.github.io/testTask_res/task_4/domain_2/dist/

Если только о ТЗ:
----------

Реализацией task_4 и task_5 является модуль task_4/domain_1/src/js/GetLsEditor.js

1. Импортировать модуль;
2. Получить экзепляр конструктора.

    let iframe = document.getElementById('iframeID');

    let promiseLsEditor = new GetLsEditor(iframe);

    Подразумевается что в конструктор передается DOM-эдемент iframе-а. Если аргумента нет или он не iframe, то в качестве корневого эл-та назначается window и далее полученный экземпляр работает с localStorage собственной страницы.
    Конструктор возвращает promise, который дожидается события 'DOMContentLoaded'.

3. Promise после fulfilled возвращает экзепляр класса LsEditor.

    promiseLsEditor.then(lsEditor => {

      ... логика ...
      
    });



Что есть в экзепляре LsEditor?

1. Метод read(key, callback, data): возвращает данные по ключу из localStorage iframe-a.

    Ключ обязателен и должен быть строкой. Если не передать key или передать не строку, метод вернет false и, если включено логирование в консоль, напишет в консоль сообщение.
    callback и data можно использовать опционально. Если callback есть, то он пробует запускаться после выполнения чтения, передавая туда в качестве аргумента data.
    При успехе возвращает данные.

2. Метод write(key, value, callback, data): записывает value по ключу key в localStorage iframe-a.
    Логика работы аналогична read, value не валидируется. При успехе возвращает true, иначе false.

3. Метод remove(key, callback, data): удаляет данные по ключу key из localStorage iframe-a.
    Логика работы аналогична read. При успехе возвращает true, иначе false.

Так же непосредственно в экземпляре есть несколько свойств для проверок, взаимодействия и конфигурации.

1. Свойство logToConsole (true / false): если true, то методы сообщают о своей работе в консоль.
2. Свойство isIframe (true / false): false, если в конструктор не передавался (или был не корректный) аргумент, а значит экземпляр работает с собственным localStorage.
3. Свойство root: ссылка на корневой элемент (window).


Если не только о ТЗ:
----------

Как обычно захотелось разнообразить задачу :). Ну и, конечно, видеть результаты тоже хотелось.

В папке task_4 находятся 2 папки: domain_1 и domain_2.

  domain_2 - для того, чтоб затянуть его в iframe, вся работа происходит с его localStorage;

  domain_1 - для того, чтобы продемонстрировать работоспособность LsEditir-а.



domain_2

Реализован очень простенький чатик:

- при загрузке страницы проверяется наличие в localStorage чата (ключ 'task4Chat'). Если есть, то на windows инициализируется пользовательское событие 'baseUpdated', которое читает "чат" и отображает его;

- при нажатии кнопки "отправить" достается "чат", к нему добавляется последнее сообщение, "чат" записыватся назад и вызывается событие 'baseUpdated'.

Для отображения сообщений ипользуется шаблон (он лежит в верстке), шаблон рендерится mustache (mustache подключен через cdn).



domain_1

На странице есть 3 элемента:

- элемент для ввода сообщений, идентичный тому, что на domain_2, но работает по другому;
- кнопка удаления истории;
- iframe из domain_2

При загрузке страницы инициализируется LsEditor, который в качестве источника получает iframe из domain_2 и ставится слушатель на кнопку "отправить".

При нажатии кнопки "отправить" берутся данные, пакуются в объект "правильной структуры" (правильной для дальнейшего восприятия шаблонизатором на domain_2) и вызывается функция sendMessage, в которую передается сформированный объект данных и экземпляр LsEditor-а.

sendMessage - просто обертка. LsEditor может читать/писать localStorage по любому ключу, поэтому для работы именно с "чатом" удобно сделать обертку.

Внутри sendMessage с помощью LsEditor-а читается "чат" из localStorage domain_2, добавляется новое сообщение и "чат" записывается обратно. При записи передается ф-я refresh в качестве callback-а и эеземпляр LsEditor-а в качестве данных для этого callback-а.

После записи вызывается callback, который инициирует событие 'baseUpdated' на window domain_2.

С кнопкой "удалить историю" та же история ), только при нажатии вызывается другая обертка (deleteHistory).



Таким образом в этой реализации полность демострируеся выполнение ТЗ.


Сборка: основной сборщик gulp, webpack для js. HTML копируется. CSS - стандартный набор (склейка, автопрефиксер, минификация). Для JS - обработка импортов и babel.

******************************
task_5
----------

Реализован в task_4.

******************************
task_6
----------
Просмотр результата: 


******************************